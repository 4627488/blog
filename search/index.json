[{"content":"Week2 - Misc - ez_brainfuzz Description 和靶机交互，发送一段Brainfuck代码，靶机会返回输出和flag的md5的相似度. 如果完全一致就会给出flag\nSolution 暴力枚举即可，注意到md5是32位的hex，直接枚举每一位即可，枚举第 $i$ 位时把其他位用'z'补齐即可，这样如果这一位是正确的，给出的相似度应该大于0，反之则没有任何位相同，应该得到0%。\n对于要输出的字符串，生成Brainfxxk代码\n1 2 3 4 5 6 7 def generate_brainfuck_code(input_string): brainfuck_code = \u0026#34;\u0026#34; for char in input_string: ascii_value = ord(char) brainfuck_code += \u0026#34;+\u0026#34; * ascii_value + \u0026#34;.\u0026#34; brainfuck_code += \u0026#34;\u0026gt;\u0026#34; return brainfuck_code 枚举\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 def get_predict(c, index): st = \u0026#34;\u0026#34; for ind in range(32): if ind == index: st += c else: st += \u0026#34;z\u0026#34; return st hex_list = [\u0026#39;0\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;,\u0026#39;3\u0026#39;,\u0026#39;4\u0026#39;,\u0026#39;5\u0026#39;,\u0026#39;6\u0026#39;,\u0026#39;7\u0026#39;,\u0026#39;8\u0026#39;,\u0026#39;9\u0026#39;,\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;F\u0026#39;] host=\u0026#39;\u0026#39; port= if __name__ == \u0026#34;__main__\u0026#34;: conn = remote(host=host,port=port) print(conn.recv().decode()) ans = \u0026#34;\u0026#34; for pos in range(32): this_ans = \u0026#34;\u0026#34; for pred in hex_list: check = get_predict(pred, pos) print(check) check = generate_brainfuck_code(check) conn.send(check + \u0026#34;\\n\u0026#34;) ret = conn.recv().decode() print(ret) sm = float(ret.split(\u0026#34;%\u0026#34;)[0].split(\u0026#34;:\u0026#34;)[1]) if sm \u0026gt; 0: this_ans = pred break ans += this_ans print(ans) Week2 - Misc - qrazy_pic_encode Description 解密二维码图片，加密方式是：\n若源图片中这个像素为黑色：加密后变为20个随机数经过离散余弦变换（Discrete Cosine Transform）并去除第0位得到的19个值。\n若源图片中这个像素为白色：加密后变为20个随机数经过两次离散余弦变换（Discrete Cosine Transform）并去除第0位得到的19个值。\nSolution 注意到是二分类问题，直接逻辑回归即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import numpy as np import ast from PIL import Image import random from sklearn.model_selection import train_test_split from sklearn.linear_model import LogisticRegression from sklearn.metrics import classification_report from scipy.fftpack import dct datas=[] labels=[] def normalize(lst): min_value = min(lst) max_value = max(lst) normalized_values = [(x - min_value) / (max_value - min_value) for x in lst] return normalized_values #generate dataset/label for i in range(50000): y = [random.random() for _ in range(20)] y1 = dct(y) if i%2: y1 = dct(y1) datas.append(normalize(y1[1:])) labels.append(i%2) X_train, X_test, y_train, y_test = train_test_split( datas, labels, test_size=0.2, random_state=42 ) print(\u0026#39;data generated\u0026#39;) #train model on CPU model = LogisticRegression() model.fit(X_train, y_train) print(\u0026#39;model trained\u0026#39;) #test model y_pred = model.predict(X_test) print(classification_report(y_test, y_pred)) #decode picture with open(\u0026#34;out.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: data = f.read() data = ast.literal_eval(data) print(len(data)) img = [model.predict([data[i : i + 19]])[0] for i in range(0, len(data), 19)] img = np.array(img).reshape((37, 37)) Image.fromarray(img * 255).convert(\u0026#34;L\u0026#34;).save(\u0026#34;decrypted.png\u0026#34;) ","date":"2024-02-02T19:00:00Z","image":"https://www.h4627488.me/110473958_p0.jpg","permalink":"https://www.h4627488.me/p/sbctf-wintercamp2024-%E4%B8%AA%E4%BA%BA%E9%83%A8%E5%88%86wp/","title":"SBCTF wintercamp2024 个人部分wp"},{"content":"最近把博客迁移到了Hugo，这是第一篇文章。\n","date":"2022-03-06T00:00:00Z","image":"https://www.h4627488.me/p/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://www.h4627488.me/p/hello-world/","title":"Hello Hugo"},{"content":"2018 每个伟大的征程，都有一个微不足道的开始。\n2018.04.24 qdacm出现了名为「4627488」的账号，小尾巴是「江南才子一枚」\n2018.04.25 4627488 在早上 05:59 提交了第一篇AC代码，题号是2652。 洛谷的第99233个账号被注册了，昵称是「_4627488」，随后提交了用C语言的P1000 ac代码\n7月 和Cola 去了某个知名省内传统强校集训，学会了多种高级算法的名称。\n2018.07.30 创建了「HUXKE 的故事 EP.2」这道题目，做法是高精度求解组合数\n只要你不停下来，路就会在脚下不断延伸\n11月 参加NOIp2018 pj组 得到166pts，以弱省线上1分拿到省一。\n那个时候真的没有想到自己能坚持OI这么久，也很愿意做一些有技巧的题目。现在看那个时候的代码就感觉写的好乱，甚至有C风格的stdio.h在里面。而且还特别喜欢封装，两行以上的复制直接就封装成一个函数，就有点OOP的思想了。\n2019 2019.6.23 洛谷首次橙名\n2019.7.11 洛谷ac70祭\n2019.7下旬-8.5 今天你sgh了吗 又去了某强校，只不过去的人多了很多，也产生了很多知名梗，比如sgh，列车长qwq 如果你有关于空调温度方面的诉求，可以拨打我的电话。 啥都别管，咱就喊 sgh tql！ 学了一些耳熟能详的高端芝士，比如「s**.io」，以及大视野在线测评的其他含义（这题wa了！），认识了短裤侠，惊奇队长。意外发现了黑脸大叔。 当然最能整活的还是sgh\n11月 参加了CSP2019的tg组（noip可能会倒闭，但绝不会不 「数据删除」 ），没有取得奖项（可能当时读不懂题目语文不好） 还认识了很多大佬\n纵使千山多万壑，犹有青鸾踏云间\n2020 2020.4 这段时间一直在上网课摸鱼，又写了一个自动下载钉钉的视频回放的python代码，甚至实现了线程池。然后沉迷方舟无法自拔。网课回放到是一点没听。\n在今年，你甚至可以百日誓师两次。\n2020.7.16 好不容易搞完了中考，又一次摸到了电脑，我的archlinux经过这么长时间已经开不开机了。一直在刷loj的题目。\n2020.9 来到了本市whk强校syzx，可以名正言顺的旷自习了（之前初中甚至没有教练搞OI） 之前所有学OI的都考上了，还认识了来自29中的gk大佬。\n2020.10 加入了龙腾510网吧，顶级享受。 在这里有黑脸大叔的殷勤教导 “我可信你了” 有优越的队友ljl “对面的寡妇怎么这么强” 有擅长随机数直接拿到90pts的大佬zzj “你要是能过了，我舔屏幕从这舔到这” 更有直接三分法拿满100pts的lkw 当然还有没写cstdio入选各省迷惑行为的大佬ysy （反复鞭尸） 以及Cola，Koala（灵异选手）等众多大佬。\n总之这段时间很有意思，我还出了一次比赛Huxke Round #0（肝帝Cola和Koala出了3次好像），其他时间都在调代码，学高级数据结构，还应黑脸大叔要求去印了一些模板（scanf快读好评），甚至还能用来送给别人当生日礼物????\n2020.11 听闻ccf整了个换皮和noip没有任何关系的csp，还要考两遍，重点是noip的时间还正好是会考当天????，好在我这年不考会考又想起cstdio了，不过可以一直翘晚自习去龙腾这点好评，导致12月份才上我第一个晚自习。 参加了csp2020，考点在大庆，这儒略历直接给我整傻了，整个考试的时间都在调那道题。 我想说ccf julian九zoo 题目质量很高，孩子很喜欢做，下次还来\n解释：julian是第一题的名称，zoo是第二题的，“julian九zoo” 顾名思义\n2020.12 这个月考noip，由于csp2020连省二都没拿到，给我带来了不小的压力，剩下的几天都在疯狂的刷题，练习骗分技巧 noip拿到100pts（参见我的noip2020游记），离省一还是差了几分????\n在纷繁杂乱的世界里，独自寻找属于自己的光荣与梦想。\n2021 4月 因为是弱省，所以我一蒟蒻也能获得省选资格，去考了一次，意料之中的没有考上????（参见2021省选摸鱼纪实）\n5月 sy竟然能参加hjhcpc我是没想到的，Cola已经退役了，我只能和Koala去打ACM。不得不说，ACM赛制真的毒瘤，不像ccf用脚出t1数据。（ccf：好的我改）\n9月 继续来龙腾学OI，龙腾网吧再次开业????，只是人有点少，新同学有homesafe和mfy。人少的好处就是梗大家都知道，比如海豹突击队，再比如????????同○子\n10月 高一的同学也来了，比如人民领袖毛主席 （毛主席万岁！） 。 然后参加了csp2020，t1把优先队列写反了 样例还都过了就离谱，只拿到后三道暴力分51pt????，哭了哭了。\n11月 我反正是要退役了，再看这小破电脑竟有感情了。 键盘缝里一堆碎头发才是最吓人的。 noip2021考之前又看看之前的代码，写写csp2021-j的题目， 突然想起来koala的方程式配平还没做。 然后就等20号考试了。\n2021.11.20 今天考noip2021，也是这篇游记的标题，我跟xty请了一整天假，mfy可太能卷了， 考点在本市29中。 发题目后一看密码「IronHeart」可太行了。 t1 直接手写链表埃氏筛一波，估计有60pts，但赛后洛谷测是ac了不知道是不是我算错了。 t2 读题感觉是个dp但是dp考场基本没写对过，所以直接枚举S，但是S求组合数却用的暴力，因为赛时一直没推出来求解组合数的方法 MO也救不了我 t3 没思路，直接写了个连样例2都过不了的假的贪心，不过样例4竟然过了。 t4 怀疑ccf出题按字数收稿费，这种题目长度随便打了个最短路，也没法维护，最后洛谷测全RE了不知道官方数据如何。\n2021.11.21 写了这篇游记，到这已经2500多字，感觉不会有什么不学OI的人看，所以，祝看到这里的人:\n1 NOIp.rp++; 与君共勉。\n江南才子一枚\n2021.11.21 A.F.O.ed\n","date":"2021-11-21T22:20:09Z","permalink":"https://www.h4627488.me/p/noip2021-%E9%80%80%E5%BD%B9%E8%AE%B0%E5%8F%8A%E5%9B%9E%E9%A1%BE/","title":"NOIp2021 退役记及回顾"},{"content":"day 0 能来考省选真是意料之外的事情。好像上次考完 noip 之后的两个月里根本没怎么做题，背的模板也快忘光了。于是就把模板都印出来了，打算再学一遍。这几天看了之前的省选题，作为弱省，全国 B 卷似乎比其他地方的省选简单但我还是不会。\n跟班主任请了一下午+第二天的假，上午的课好像很闲，最后一节是数学，复数啥的根本不会。但是逃过考阿房宫赋和查数学校本倒是挺不错的 （upd 4.11：可恶 没查也没考）\n到火车上陪 Cola（\u0026lt;\u0026ndash;大佬）打了一下单源最短路径，又看了一下线段树，可持久化什么的不会考的反正我已经全忘了，平衡树确实很烦人，后来又看了对拍的代码，也许会的题做完了还有功夫对拍两下（？）。koala 出了一些毒瘤题目，玄学到做了很久都没有过任何测试点。\n不过正如 Cola 所说的\n样例过了就是 AC 了，过不了就是编译器的问题\n直接 printf 岂不是更好\n毕竟是灵异杯嘛\n晚上去报道去了，还玩了一会 NOI linux（指cd / \u0026amp;\u0026amp; sudo rm -rf **），好在我有删库前备份的习惯。\nCola 决定试机的时候打线段树%%%，然而没有网\n可恶为啥别的学校校服那么好看\n然后晚上自己做了多项式的模板，exp 已经全忘掉了。然后又重学了一遍。\n好家伙，写了这么多次游记似乎还是跟以前一样的流水账。\n明天 rp++;\nday 1 很早就去了哈师大附中的省选考点。根据去年的省选 b 卷，t1肯定很水（只会d1t1）\nt1 果然看起来很简单， 应该是普及- （儒略历也是普及- 爬了） 作为ccf，估计会有卡常的点。\nt2 赛后得知这是a卷t1，一开始觉得是分治，但是最多翻牌数m是全局的，这似乎就没法分治了。然后就推断出翻牌肯定从最大最小翻起（废话），但是没有用上。最后的打了个优雅的暴力，就是对每个数计算使它成为最值的最小翻牌数，然后再遍历扫出ans\nt3 全源最短路径？并查集？可持久化？蛤？不会？暴力都打不出来\nday 2 t1 啊这 数论吗 打了暴力，之后觉得模数应该是最大值，证不出来，对拍没问题，那就……算对了？n^2的复杂度，也许60pts？\nt2 发现是树抛 不知道怎么打 那就bfs 最后离线了询问 bfs的时候在碰到第一个宝石之前的就一块查了 数据说可能退化成链？\nt3 想到了qdacm解封榜的时候的bgm 一种暴力思路就是枚举排名全排列，然后check是常数复杂度，全排列用的stl，ans2差了1，不知道为什么，难道分数不同不算同一种情况，还有如果给前n-1个队 0 ac数最后一个队给m不符合题意吗\n省选找规律选手\n4.11 2021 今年是AFO之年\n","date":"2021-04-11T15:58:31Z","permalink":"https://www.h4627488.me/p/2021-%E7%9C%81%E9%80%89%E6%91%B8%E9%B1%BC%E7%BA%AA%E5%AE%9E/","title":"2021 省选摸鱼纪实"},{"content":"期末后我校上了四天网课，于是就有了这篇博客。 这篇博客只针对云服务器开服教程，实际上你可以通过端口映射实现联机，但是服务器可以 24 小时在线。\n0x00 食用前你需要 一个实名注册的云服务供应商的账号（阿里云，腾讯云之类的） 买一个云主机/轻量应用服务器 0x01 构建 我服务器端使用的系统是 Ubuntu 20.04 LTS 首先用 SSH 连上服务器，vscode 操作比较方便，在 vscode 扩展商店里找到 Remote-SSH，安装\n左下角 SSH 连接到你的服务器，连接好之后打开一个文件夹作服务器文件夹\n从这里下载 Minecraft Server 核心(现在是 1.16.4) https://imgse.com/i/sQSPjU 把server.jar复制到服务器的文件夹里\n从这里下载在服务器上的 jre.解压复制到server.jar的目录里。\n把 下载到的 java 的文件夹名改成“jre“，打开 bash 运行\n1 jre/bin/java -Xmx1024M -Xms1024M -jar server.jar nogui 然后得到这个结果 你需要打开 eula.txt ，把其中的\n1 eula=false 改成\n1 eula=true 再运行一遍，出现\n1 2 [17:04:12] [Server thread/INFO]: Time elapsed: 2863 ms [17:04:12] [Server thread/INFO]: Done (3.028s)! For help, type \u0026#34;help\u0026#34; 表明服务器开成功了。 在客户端输入服务器的 ip 就可以登入\n0x02 设置 文件夹下已经出现 server.properties 文件\npvp=true :是否可以伤害其他玩家 white-list=false :启用白名单 online-mode=true :使用正版认证 motd= :服务器的说明 enable-command-block=true :允许使用命令方块 存档保存在 world 下。\n0x03 存档自动备份\u0026amp;\u0026amp;崩溃自动重启 把这个保存成 start.sh(Ubuntu)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/bash cut=0 ret=0 myFile=\u0026#34;stop\u0026#34; while [ ! -f \u0026#34;$myFile\u0026#34; ] do let cut++ jre/bin/java -Xmx2048M -Xms2048M -jar fabric-server-launch.jar nogui OP_MODE=$? if [ \u0026#34;$OP_MODE\u0026#34; -eq \u0026#34;0\u0026#34; ];then break fi filename=\u0026#34;backup_`date +%y%m%d%H%M%S`.zip\u0026#34; zip -r backup/$filename world/ done 之后通过 .\\start.sh 运行服务器，这样每次崩溃之后服务器就会备份重开。\n0x3f 后记 本来打算和别人联机玩，结果折腾服务器无法自拔，另外两个大佬自己玩的 φ(≧ω≦*)♪\n","date":"2021-01-09T17:24:35Z","image":"https://www.h4627488.me/p/minecraft-java-%E5%8E%9F%E7%89%88%E5%BC%80%E6%9C%8D/sQiY11.md_hu45b1c857fb32295ffaa5a14f40559b0d_485648_120x120_fill_box_smart1_3.png","permalink":"https://www.h4627488.me/p/minecraft-java-%E5%8E%9F%E7%89%88%E5%BC%80%E6%9C%8D/","title":"Minecraft Java 原版开服"},{"content":"day -1 : 12 月 3 日 机房最后一天集训了，依照教练指示，大家开始收拾机房。收拾的时候，大家的情绪不免有些低落，毕竟是最后一天了，之后，这个被称为“龙腾网吧”的机房就会迎来半年的平静。\n从 8 月末我来到实验中学开始，我来龙腾近 100 天。在这一百天里，我感受到了机房的愉悦气氛，lkw 的三分法 AC， zzj 随机数过 80pts，ysy 多得 90pts 的小技巧， 机房承载了许多的欢声笑语的回忆。\n收拾的时候，我发现键盘缝里好多头发。\n最后 Cola 在黑板上写了“龙腾欢迎您”，ljl 开始删他的 lol ，我 sudo rm -rf * 了我的电脑（十一集训事件），完成了和龙腾 510 的告别。\nday 0 : 12 月 4 日 由于 HL 会考，我们高一在这天得以放一下午的假，而我们要出征 noip2020 了。 下午回家打了线段树模板，又看了一些模板，期望能压中一个。 晚上到了哈尔滨，我发现我们 8 个人只有 4 个住我住的酒店。在酒店里，我又打了打智颓上的题目，其他人都到了我的房间，都是男的我害怕啊，堪称龙腾 320。\nljl 打他的 LOL，后来回去了，我和 zzj 切题切到零点。总担心 noip 不出阳间题，后来也难以入睡，就开始想儒略历的做法。(ptsd)\nday 1 : 12 月 5 日 赛前 早上 5 点就起来了，心里全是格里高利和他的历法。\n很快找到了考点，考试很快开始了。\n赛时 T1 一看，啊，原来是 DAG。我一个拓扑排序，就打上去了，很快啊，分数也好维护，T1 出题人真谢谢你，啊这高精我是真没想到。\nT2 牢记儒略历教训，太长题面直接看后面题，别浪费时间（结果这是最好暴力的）\nT4 求进行一套走位后的最终位移，再求每套最远走到的区间，然后判断是否在一套内。轻松骗到 35pts。其他的不会了。\nT3 那一天，ccf 终于会出一道 spj 的。暴力做法：模拟每个栈，从第一个栈开始，以最底下的颜色为这个栈的颜色，把其他栈凡是有的全抢过来，无用的随便放。样例 4 直接超 81w。\n赛后 赛后发现分数加法的临时变量用的int\n赛后听说 t1 要高精，我直接傻了。\n洛谷自测发现 t1 那个int 90pts -\u0026gt; 70pts\nupd 12.8 :ccf 数据给我判了 60pts，是没开高精度的分\n弱省 rank 20\n","date":"2020-12-09T23:02:32Z","permalink":"https://www.h4627488.me/p/noip-2020-%E6%B8%B8%E8%AE%B0/","title":"NOIP 2020 游记"},{"content":"常用垃圾题黑题模板 长度,是难度的一部分.\n快读 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 inline int getInt() { ll x = 0, f = 1; char ch = getchar(); while (ch \u0026lt; \u0026#39;0\u0026#39; || ch \u0026gt; \u0026#39;9\u0026#39;) { if (ch == \u0026#39;-\u0026#39;) f = -1; ch = getchar(); } while (ch \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; ch \u0026lt;= \u0026#39;9\u0026#39;) { x = (x \u0026lt;\u0026lt; 1) + (x \u0026lt;\u0026lt; 3) + (ch ^ 48); ch = getchar(); } return x * f; } inline void out(int a) { if (a \u0026gt;= 10) out(a / 10); putchar(a % 10 + \u0026#39;0\u0026#39;); } 快速排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 100000 #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) int n; int a[maxn+5]; int main() { read(n); for(int i=1;i\u0026lt;=n;i++) read(a[i]); sort(a+1,a+n+1); for(int i=1;i\u0026lt;=n;i++) printf(\u0026#34;%d \u0026#34;,a[i]); return 0; } 并查集 注意：不能忘了路径压缩\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 10000 #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) int n,m; int fa[maxn+5]; int find(int x) { if(!fa[x]) return x; return fa[x]=find(fa[x]); } int main() { read(n),read(m); while(m--) { int x,y,z; read(z),read(x),read(y); int fa1=find(x),fa2=find(y); if(z==1) { if(fa1==fa2) continue; else fa[fa1]=fa2; } else { if(fa1==fa2) printf(\u0026#34;Y\\n\u0026#34;); else printf(\u0026#34;N\\n\u0026#34;); } } return 0; } 快速幂 注意：在最后输出ans时要再模一次p，以免被指数为0模数为1的情况卡掉\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define ll long long #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) int a,b,p; int main() { read(a),read(b),read(p); int aa=a,bb=b; int ans=1; while(b) { if(b\u0026amp;1) ans=(ll)ans*a%p; b\u0026gt;\u0026gt;=1,a=(ll)a*a%p; } printf(\u0026#34;%d^%d mod %d=%d\u0026#34;,aa,bb,p,ans%p); return 0; } 矩阵快速幂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 100 #define md (int)(1e9+7) #define ll long long int n; ll K; struct Node{ ll a[maxn+5][maxn+5]; Node(){memset(a,0,sizeof(a));} void build() {for(int i=1;i\u0026lt;=n;i++) a[i][i]=1;} }; Node operator * (const Node\u0026amp; x,const Node\u0026amp; y) { Node z; for(int k=1;k\u0026lt;=n;k++) { for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=n;j++) { z.a[i][j]=(z.a[i][j]+x.a[i][k]*y.a[k][j]%md)%md; } } } return z; } Node a,ans; int main() { scanf(\u0026#34;%d%lld\u0026#34;,\u0026amp;n,\u0026amp;K); for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=n;j++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a.a[i][j]); ans.build(); do{ if(K\u0026amp;1) ans=ans*a; a=a*a,K\u0026gt;\u0026gt;=1; } while(K); for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=n;j++) printf(\u0026#34;%lld \u0026#34;,ans.a[i][j]); printf(\u0026#34;\\n\u0026#34;); } return 0; } 线性筛判素数 注意：\n1、一定要背熟模板\n2、不要忘写 \u0026amp;\u0026amp;i*prm[j]\u0026lt;=n 导致数组越界\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 10000000 #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) int n,m; int Phi[maxn+5]; vector\u0026lt;int\u0026gt; prm; void makephi() { Phi[1]=1; for(int i=2;i\u0026lt;=n;i++) { Phi[i]=i; } for(int i=2;i\u0026lt;=n;i++) { if(Phi[i]==i) Phi[i]--,prm.push_back(i); for(int j=0;j\u0026lt;prm.size()\u0026amp;\u0026amp;i*prm[j]\u0026lt;=n;j++) { int x=prm[j]; if(i%x) Phi[i*x]=Phi[i]*x; else Phi[i*x]=Phi[i]*Phi[x]; } } } int main() { read(n),read(m); makephi(); while(m--) { int x; read(x); if(Phi[x]==x-1) printf(\u0026#34;Yes\\n\u0026#34;); else printf(\u0026#34;No\\n\u0026#34;); } return 0; } 堆（优先队列） 注意：priority_queue是大根堆，若要使用小跟堆需要push相反数，或使用struct封装后定义小于运算符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) priority_queue\u0026lt;int\u0026gt; que; int main() { int n; read(n); while(n--) { int opr; read(opr); if(opr==1) { int x; read(x); que.push(-x); } else if(opr==2) printf(\u0026#34;%d\\n\u0026#34;,-que.top()); else que.pop(); } return 0; } 字符串哈希 注意：\n1、可以用 unsigned long long （ull）的自然溢出处理取模问题\n2、使用双哈希不容易产生冲突\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 10000 #define maxm 1500 #define ull unsigned long long #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) struct Pair{ ull x,y; Pair(){} Pair(ull xx,ull yy) {x=xx,y=yy;} bool operator \u0026lt; (const Pair\u0026amp; oth) const { return x\u0026lt;oth.x||(x==oth.x\u0026amp;\u0026amp;y\u0026lt;oth.y); } bool operator == (const Pair\u0026amp; oth) const { return x==oth.x\u0026amp;\u0026amp;y==oth.y; } }; int n; Pair hsh[maxn+5]; const int md1=13,md2=131; void make_hash(int x,char* s,int m) { ull hsh1=0,hsh2=0; for(int i=0;i\u0026lt;m;i++) { hsh1=hsh1*md1+s[i]+1; hsh2=hsh2*md2+s[i]+1; } hsh[x]=Pair(hsh1,hsh2); } int main() { read(n); for(int i=1;i\u0026lt;=n;i++) { char s[maxm+5]; scanf(\u0026#34;%s\u0026#34;,s); make_hash(i,s,strlen(s)); } sort(hsh+1,hsh+n+1); int ans=0; for(int i=1;i\u0026lt;=n;i++) { if(hsh[i]==hsh[i-1]) continue; ans++; } printf(\u0026#34;%d\u0026#34;,ans); return 0; } 最小生成树 注意：\n1、正向定义小于运算符\n2、图不连通的判断方法是求出的最小生成树的边数不等于n-1\n3、边集的数组大小要开maxm，开成了maxn就彻底凉了\n4、接上，n==m时一定要注意，不要把n、m弄反\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 5000 #define maxm 200000 #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) struct Edge{ int x,y,z; Edge(){} Edge(int xx,int yy,int zz) { x=xx,y=yy,z=zz; } bool operator \u0026lt; (const Edge\u0026amp; oth) const { return z\u0026lt;oth.z; } }; int n,m; Edge e[maxm+5]; int fa[maxn+5]; int find(int x) { if(fa[x]) return fa[x]=find(fa[x]); else return x; } int kruskal() { int cnt=0,s=0; for(int i=1;i\u0026lt;=m;i++) { int fa1=find(e[i].x),fa2=find(e[i].y); if(fa1==fa2) continue; fa[fa1]=fa2; cnt++; s+=e[i].z; } if(cnt==n-1) return s; else return -1; } int main() { read(n),read(m); for(int i=1;i\u0026lt;=m;i++) read(e[i].x),read(e[i].y),read(e[i].z); sort(e+1,e+m+1); int ans=kruskal(); if(ans==-1) printf(\u0026#34;orz\u0026#34;); else printf(\u0026#34;%d\u0026#34;,ans); return 0; } 最短路 dijkstra 注意：反向定义小于运算符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 100000 #define maxm 200000 #define inf ((int)1e9) #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) struct Edge{ int x,y,z; Edge(){} Edge(int xx,int yy,int zz) {z=zz,y=yy,z=zz;} }; struct Node{ int y,z; Node(){} Node(int yy,int zz){y=yy,z=zz;} bool operator \u0026lt; (const Node\u0026amp; oth) const { return z\u0026gt;oth.z; } }; int n,m,s; vector\u0026lt;Edge\u0026gt; g[maxn+5]; int dist[maxn+5]; priority_queue\u0026lt;Node\u0026gt; que; bool vis[maxn+5]; void readin() { read(n),read(m),read(s); for(int i=1;i\u0026lt;=m;i++) { int x,y,z; read(x),read(y),read(z); g[x].push_back(Edge(x,y,z)); } } void dijkstra() { for(int i=1;i\u0026lt;=n;i++) if(i!=s) dist[i]=inf; que.push(Node(s,0)); while(!que.empty()) { int h=que.top().y; que.pop(); if(vis[h]) continue; vis[h]=true; for(int i=0;i\u0026lt;g[h].size();i++) { int y=g[h][i].y; if(dist[y]\u0026gt;dist[h]+g[h][i].z) { dist[y]=dist[h]+g[h][i].z; que.push(Node(y,dist[y])); } } } for(int i=1;i\u0026lt;=n;i++) printf(\u0026#34;%d \u0026#34;,dist[i]); } int main() { readin(); dijkstra(); return 0; } 最短路 floyd 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 100 #define maxm 10000 #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) #define inf (1\u0026lt;\u0026lt;30) int n,m; int a[maxm+5]; int g[maxn+5][maxn+5]; int dist[maxn+5][maxn+5]; void readin() { read(n),read(m); for(int i=1;i\u0026lt;=m;i++) read(a[i]); for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=n;j++) read(g[i][j]); } void floyd() { for(int i=1;i\u0026lt;=n;i++) for(int j=1;j\u0026lt;=n;j++) dist[i][j]=g[i][j]; for(int k=1;k\u0026lt;=n;k++) { for(int i=1;i\u0026lt;=n;i++) { for(int j=1;j\u0026lt;=n;j++) { dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j]); } } } } void print() { int ans=0; for(int i=2;i\u0026lt;=m;i++) { ans+=dist[a[i-1]][a[i]]; } printf(\u0026#34;%d\u0026#34;,ans); } int main() { readin(); floyd(); print(); return 0; } 树状数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 500000 #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) #define lowbit(x) (x\u0026amp;-x) int n,m; int sum[maxn+5]; void add(int x,int w) { while(x\u0026lt;=n) { sum[x]+=w; x+=lowbit(x); } } int query(int x) { int ans=0; while(x\u0026gt;0) { ans+=sum[x]; x-=lowbit(x); } return ans; } int main() { read(n),read(m); for(int i=1;i\u0026lt;=n;i++) { int x; read(x); add(i,x); } while(m--) { int opr,x,y; read(opr),read(x),read(y); if(opr==1) add(x,y); else printf(\u0026#34;%d\\n\u0026#34;,query(y)-query(x-1)); } return 0; } kmp 注意：nxt数组的意义——最长公共前后缀长\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 1000000 char a[maxn+5],b[maxn+5]; int nxt[maxn+5]; int n,m; int main(){ scanf(\u0026#34;%s%s\u0026#34;,a+1,b+1); n=strlen(a+1),m=strlen(b+1); for(int i=2;i\u0026lt;=m;i++) { int j=nxt[i-1]; while(j\u0026amp;\u0026amp;b[i]!=b[j+1]) j=nxt[j]; if(b[j+1]!=b[i]) nxt[i]=0; else nxt[i]=j+1; } int j=0; for(int i=1;i\u0026lt;=n;i++) { while(a[i]!=b[j+1]\u0026amp;\u0026amp;j) j=nxt[j]; if(a[i]==b[j+1]) j++; if(j==m) { printf(\u0026#34;%d\\n\u0026#34;,i-m+1); } } for(int i=1;i\u0026lt;=m;i++) printf(\u0026#34;%d \u0026#34;,nxt[i]); return 0; } lca倍增 注意：处理到第2^20个祖先就足够过至少1e6的数据范围了，开大了会影响效率\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 500000 #define maxm 500000 #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) int n,m,rt; vector\u0026lt;int\u0026gt; tr[maxn+5]; int anc[maxn+5][30]; int d[maxn+5]; void dfs(int x,int fa) { anc[x][0]=fa; for(int i=1;i\u0026lt;=20;i++) { anc[x][i]=anc[anc[x][i-1]][i-1]; } d[x]=d[fa]+1; for(int i=0;i\u0026lt;tr[x].size();i++) { int y=tr[x][i]; if(y==fa) continue; dfs(y,x); } } int findLCA(int x,int y) { if(d[x]\u0026lt;d[y]) swap(x,y); for(int i=20;i\u0026gt;=0;i--) { if(d[anc[x][i]]\u0026gt;=d[y]) x=anc[x][i]; } if(x==y) return x; for(int i=20;i\u0026gt;=0;i--) { if(anc[x][i]!=anc[y][i]) { x=anc[x][i],y=anc[y][i]; } } return anc[x][0]; } int main() { read(n),read(m),read(rt); for(int i=1;i\u0026lt;n;i++) { int x,y; read(x),read(y); tr[x].push_back(y); tr[y].push_back(x); } dfs(rt,0); while(m--) { int x,y; read(x),read(y); printf(\u0026#34;%d\\n\u0026#34;,findLCA(x,y)); } return 0; } 二分图匹配 注意：要用use数组标记下访问过的点，不然会重复搜索\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 1000 #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) int n,m,e; int g[maxn+5][maxn+5]; int mch[maxn+5]; bool use[maxn+5]; bool dfs(int x) { for(int i=1; i\u0026lt;=m; i++) { if(g[x][i]\u0026amp;\u0026amp;0==use[i]) { use[i]=true; if(0==mch[i]||dfs(mch[i])) { mch[i]=x; return true; } } } return false; } int main() { read(n),read(m),read(e); for(int i=1; i\u0026lt;=e; i++) { int x,y; read(x),read(y); if(x\u0026gt;n||y\u0026gt;m) continue; g[x][y]=true; } int cnt=0; for(int i=1; i\u0026lt;=n; i++) { memset(use,0,sizeof(use)); if(dfs(i)) cnt++; } printf(\u0026#34;%d\u0026#34;,cnt); return 0; } 割点 注意：第一个节点的特判\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) #define maxn 100000 int n,m; vector\u0026lt;int\u0026gt; g[maxn+5]; int pre[maxn+5],low[maxn+5],cnt; bool iscut[maxn+5]; void tarjan(int x,int fa) { pre[x]=low[x]=++cnt; int chd=0; for(int i=0;i\u0026lt;g[x].size();i++) { int y=g[x][i]; if(y==fa) continue; if(!pre[y]) { chd++; tarjan(y,x); if(pre[x]\u0026lt;=low[y]\u0026amp;\u0026amp;fa) iscut[x]=true; low[x]=min(low[x],low[y]); } else if(pre[y]\u0026lt;pre[x]) low[x]=min(low[x],pre[y]); } if(fa==0\u0026amp;\u0026amp;chd\u0026gt;1) iscut[x]=true; } int main() { read(n),read(m); for(int i=1;i\u0026lt;=m;i++) { int x,y; read(x),read(y); g[x].push_back(y),g[y].push_back(x); } for(int i=1;i\u0026lt;=n;i++) { if(!pre[i]) tarjan(i,0); } int ans=0; for(int i=1;i\u0026lt;=n;i++) if(iscut[i]) ans++; printf(\u0026#34;%d\\n\u0026#34;,ans); for(int i=1;i\u0026lt;=n;i++) if(iscut[i]) printf(\u0026#34;%d \u0026#34;,i); return 0; } 缩点 注意：找反边时注意要在同一次dfs中遍历到的点才能算，即需要判断col[y]==0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) #define maxn 100000 int n,m; vector\u0026lt;int\u0026gt; g[maxn+5]; int v[maxn+5]; int pre[maxn+5],low[maxn+5],cnt=0; stack\u0026lt;int\u0026gt; stk; int col[maxn+5],sum,w[maxn+5]; vector\u0026lt;int\u0026gt; a[maxn+5]; int dist[maxn+5]; int dfs(int x) { if(dist[x]) return dist[x]; for(int i=0;i\u0026lt;a[x].size();i++) { dist[x]=max(dist[x],dfs(a[x][i])); } dist[x]+=w[x]; return dist[x]; } void make_a() { for(int i=1;i\u0026lt;=n;i++) { for(int j=0;j\u0026lt;g[i].size();j++) { int y=g[i][j]; if(col[i]!=col[y]) a[col[i]].push_back(col[y]); } } } void tarjan(int x) { pre[x]=low[x]=++cnt; stk.push(x); for(int i=0;i\u0026lt;g[x].size();i++) { int y=g[x][i]; if(!pre[y]) { tarjan(y); low[x]=min(low[x],low[y]); } else if(pre[x]\u0026gt;pre[y]\u0026amp;\u0026amp;!col[y]) low[x]=min(low[x],pre[y]); } if(low[x]\u0026gt;=pre[x]) { int u;sum++; do{ u=stk.top();stk.pop(); col[u]=sum; w[sum]+=v[u]; } while(u!=x); } } int main() { read(n),read(m); for(int i=1;i\u0026lt;=n;i++) read(v[i]); for(int i=1;i\u0026lt;=m;i++) { int x,y; read(x),read(y); g[x].push_back(y); } for(int i=1;i\u0026lt;=n;i++) { if(!pre[i]) tarjan(i); } make_a(); for(int i=1;i\u0026lt;=sum;i++) if(!dist[i]) dfs(i); int ans=0; for(int i=1;i\u0026lt;=sum;i++) ans=max(ans,dist[i]); printf(\u0026#34;%d\u0026#34;,ans); return 0; 最大流 dinic 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; #define maxn 200000 #define read(x) scanf(\u0026#34;%d\u0026#34;,\u0026amp;x) #define inf (1\u0026lt;\u0026lt;30) struct Edge{ int u,v,w; Edge(){} Edge(int uu,int vv,int ww) {u=uu,v=vv,w=ww;} }; int n,m,S,T; Edge e[maxn+5]; int h[maxn+5],nxt[maxn+5],cnt=-1; void add_edge(int u,int v,int w) { e[++cnt]=Edge(u,v,w); nxt[cnt]=h[u]; h[u]=cnt; } int c[maxn+5],d[maxn+5]; queue\u0026lt;int\u0026gt; que; bool bfs() { memset(d,0,sizeof(d)),d[S]=1; que.push(S); while(!que.empty()) { int x=que.front();que.pop(); for(int i=h[x];~i;i=nxt[i]) { Edge y=e[i]; if(d[y.v]||y.w==0) continue; d[y.v]=d[x]+1; que.push(y.v); } } return d[T]; } int dfs(int x,int w) { if(x==T) return w; for(int\u0026amp; i=c[x];~i;i=nxt[i]) { Edge y=e[i]; if(d[y.v]!=d[x]+1||y.w==0) continue; int z=dfs(y.v,min(w,y.w)); if(z) { e[i].w-=z; e[i^1].w+=z; return z; } } return 0; } int dinic() { int ans=0; while(bfs()) { for(int i=1;i\u0026lt;=n;i++) c[i]=h[i]; while(int x=dfs(S,inf)) ans+=x; } return ans; } int main() { memset(nxt,-1,sizeof(nxt)); memset(h,-1,sizeof(h)); read(n),read(m),read(S),read(T); for(int i=1;i\u0026lt;=m;i++) { int x,y,z; read(x),read(y),read(z); add_edge(x,y,z);add_edge(y,x,0); } int ans=dinic(); printf(\u0026#34;%d\u0026#34;,ans); return 0; } 加法乘法求和线段树 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 #include \u0026lt;bits/stdc++.h\u0026gt; #define int long long #define maxn 400010 using namespace std; int n, m, p; struct a { int v, mul, add; } xds[maxn]; int num[maxn]; inline void build(int root, int l, int r) { xds[root].add = 0; xds[root].mul = 1; if (l == r) { xds[root].v = num[l] % p; return; } int m = (l + r) / 2; build(root * 2, l, m); build(root * 2 + 1, m + 1, r); xds[root].v = (xds[root * 2].v + xds[root * 2 + 1].v) % p; } inline void pushdown(int root, int l, int r) { int m = (l + r) / 2; //value xds[root * 2].v *= xds[root].mul; xds[root * 2].v %= p; xds[root * 2].v += xds[root].add * (m - l + 1); xds[root * 2].v %= p; xds[root * 2 + 1].v *= xds[root].mul; xds[root * 2 + 1].v %= p; xds[root * 2 + 1].v += xds[root].add * (r - m); xds[root * 2 + 1].v %= p; //lazytag xds[root * 2].mul *= xds[root].mul; xds[root * 2].mul %= p; xds[root * 2].add *= xds[root].mul; xds[root * 2].add %= p; xds[root * 2].add += xds[root].add; xds[root * 2].add %= p; xds[root * 2 + 1].mul *= xds[root].mul; xds[root * 2 + 1].mul %= p; xds[root * 2 + 1].add *= xds[root].mul; xds[root * 2 + 1].add %= p; xds[root * 2 + 1].add += xds[root].add; xds[root * 2 + 1].add %= p; //init xds[root].mul = 1; xds[root].add = 0; } inline void mul(int root, int l, int r, int f, int t, int k) { if (r \u0026lt; f || t \u0026lt; l) { return; } if (f \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= t) { xds[root].mul *= k; xds[root].mul %= p; xds[root].add *= k; xds[root].add %= p; xds[root].v *= k; xds[root].v %= p; return; } int m = (l + r) / 2; pushdown(root, l, r); mul(root * 2, l, m, f, t, k); mul(root * 2 + 1, m + 1, r, f, t, k); xds[root].v = (xds[root * 2].v + xds[root * 2 + 1].v) % p; } inline void add(int root, int l, int r, int f, int t, int k) { if (r \u0026lt; f || t \u0026lt; l) { return; } if (f \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= t) { xds[root].add += k; xds[root].add %= p; xds[root].v += k * (r - l + 1); xds[root].v %= p; return; } int m = (l + r) / 2; pushdown(root, l, r); add(root * 2, l, m, f, t, k); add(root * 2 + 1, m + 1, r, f, t, k); xds[root].v = (xds[root * 2].v + xds[root * 2 + 1].v) % p; } inline int query(int root, int l, int r, int f, int t) { if (r \u0026lt; f || t \u0026lt; l) { return 0; } if (f \u0026lt;= l \u0026amp;\u0026amp; r \u0026lt;= t) { return xds[root].v % p; } pushdown(root, l, r); int m = (l + r) / 2; return (query(root * 2, l, m, f, t) + query(root * 2 + 1, m + 1, r, f, t)) % p; } signed main() { int tp1, tp2, tp3, tp4; scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;n, \u0026amp;m, \u0026amp;p); for (int i = 1; i \u0026lt;= n; i++) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;num[i]); } build(1, 1, n); while (m--) { scanf(\u0026#34;%lld\u0026#34;, \u0026amp;tp1); switch (tp1) { case 1: scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;tp2, \u0026amp;tp3, \u0026amp;tp4); mul(1, 1, n, tp2, tp3, tp4); break; case 2: scanf(\u0026#34;%lld%lld%lld\u0026#34;, \u0026amp;tp2, \u0026amp;tp3, \u0026amp;tp4); add(1, 1, n, tp2, tp3, tp4); break; case 3: scanf(\u0026#34;%lld%lld\u0026#34;, \u0026amp;tp2, \u0026amp;tp3); cout \u0026lt;\u0026lt; query(1, 1, n, tp2, tp3) \u0026lt;\u0026lt; endl; break; } } return 0; } ","date":"2020-11-06T23:16:26Z","permalink":"https://www.h4627488.me/p/%E5%B8%B8%E7%94%A8%E8%A3%B8%E9%A2%98%E6%A8%A1%E6%9D%BF/","title":"常用裸题模板"}]